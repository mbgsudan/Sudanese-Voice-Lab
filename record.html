<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ØªØ³Ø¬ÙŠÙ„ ØµÙˆØª Ø¬Ø¯ÙŠØ¯ | ØµÙˆØªÙ†Ø§</title>
  <link rel="stylesheet" href="styles.css">
  <script src="config.js"></script>
</head>
<body>
  <div class="container">
    <h1>ğŸ™ï¸ ØªØ³Ø¬ÙŠÙ„ ØµÙˆØª Ø¬Ø¯ÙŠØ¯</h1>
    <div class="card">
      <p class="meta">Ø§Ù‚Ø±Ø£ Ø§Ù„Ù†Øµ Ø¨ÙˆØ¶ÙˆØ­ ÙˆØ¨Ø·Ø¨ÙŠØ¹ØªÙƒ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†ÙŠØ© ğŸ‘Œ</p>
      <p id="counter" class="meta">0/0</p>
      <div id="textBox" class="card" style="background:#0b1113;border:1px solid #122">
        <h2 id="currentText">Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„...</h2>
        <div class="row">
          <button class="btn outline" id="prev">â®ï¸ Ù†Øµ Ø³Ø§Ø¨Ù‚</button>
          <button class="btn outline" id="skip">â­ï¸ ØªØ®Ø·Ù‘ÙŠ Ø§Ù„Ù†Øµ</button>
        </div>
      </div>
      <div class="pulse" id="pulse"></div>
      <div class="center">
        <button class="btn mint" id="recordBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ğŸ¤</button>
      </div>
      <p id="status" class="meta"></p>
    </div>
  </div>

<script type="module">
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
  const supabase = createClient(window.SAWTNA.SUPABASE_URL, window.SAWTNA.SUPABASE_ANON);

  const counterEl = document.getElementById('counter');
  const textEl = document.getElementById('currentText');
  const statusEl = document.getElementById('status');
  const pulse = document.getElementById('pulse');
  const prevBtn = document.getElementById('prev');
  const skipBtn = document.getElementById('skip');
  const recordBtn = document.getElementById('recordBtn');

  let texts = [], idx = 0;
  let mediaRecorder, chunks = [];

  async function loadTexts(){
    const { data, error } = await supabase.from('texts').select('content').order('id');
    if(error || !data || !data.length){
      texts = [
        "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… ÙŠØ§ Ø¬Ù…Ø§Ø¹Ø©.",
        "Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø¬Ùˆ Ø¬Ù…ÙŠÙ„ ÙÙŠ Ø§Ù„Ø®Ø±Ø·ÙˆÙ….",
        "Ø£Ù†Ø§ Ø¨Ø­Ø¨ Ø§Ù„Ø´Ø§ÙŠ Ø¨Ø§Ù„Ø­Ù„ÙŠØ¨.",
        "Ø³Ø¬Ù„ ØµÙˆØªÙƒ Ø¨Ø§Ù„Ù„Ù‡Ø¬Ø© Ø§Ù„Ø³ÙˆØ¯Ø§Ù†ÙŠØ©!"
      ];
      statusEl.textContent = "âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØµÙˆØµ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©ØŒ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ù†ØµÙˆØµ Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©.";
      statusEl.className = "meta msg-error";
    }else{
      texts = data.map(x=>x.content);
    }
    render();
  }

  function render(){
    textEl.textContent = texts[idx];
    counterEl.textContent = `${idx+1}/${texts.length}`;
  }

  prevBtn.onclick = ()=>{ if(idx>0){ idx--; render(); }};
  skipBtn.onclick = ()=>{ if(idx<texts.length-1){ idx++; render(); } };

  function beep(freq=600, dur=0.12){
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine'; osc.frequency.value = freq;
    osc.connect(gain); gain.connect(ctx.destination);
    gain.gain.value = 0.2;
    osc.start(); osc.stop(ctx.currentTime + dur);
  }

  async function startRecord(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];
      mediaRecorder.ondataavailable = e => chunks.push(e.data);
      mediaRecorder.onstop = onStop;

      // countdown
      let c = 3;
      statusEl.textContent = `â³ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ø¹Ø¯ ${c}...`;
      const t = setInterval(()=>{
        c--;
        if(c>0){ statusEl.textContent = `â³ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ø¹Ø¯ ${c}...`; }
        else{
          clearInterval(t);
          pulse.style.display = 'block';
          statusEl.textContent = "ğŸ™ï¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...";
          beep(900, 0.09);
          mediaRecorder.start();
          setTimeout(()=>{
            mediaRecorder.stop();
            pulse.style.display = 'none';
            beep(500, 0.09);
          }, 4500);
        }
      }, 1000);
    }catch(e){
      alert("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ø§ÙŠÙƒØ±ÙˆÙÙˆÙ†");
    }
  }

  async function onStop(){
    const blob = new Blob(chunks, { type:'audio/webm' });
    const path = `voice_${Date.now()}.webm`;
    const { error } = await supabase.storage.from(window.SAWTNA.BUCKET).upload(path, blob);
    if(error){ statusEl.textContent = "âŒ ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØªØ³Ø¬ÙŠÙ„"; statusEl.className = "meta msg-error"; return; }

    // Ø§Ø®ØªÙŠØ§Ø±ÙŠ: Ø¥Ø¯Ø±Ø§Ø¬ Ø³Ø·Ø± ÙÙŠ Ø¬Ø¯ÙˆÙ„ recordings (Ø¥Ù† ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§ Ø¨Ø¯ÙˆÙ† speaker/text)
    try{
      await supabase.from('recordings').insert({ storage_path: path, status:'pending' });
    }catch(e){ /* ignore if constraints */ }

    statusEl.textContent = "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ³Ø¬ÙŠÙ„!";
    statusEl.className = "meta";

    if(idx < texts.length-1){ idx++; render(); }
    else{ recordBtn.disabled = True; textEl.textContent = "ğŸ‰ Ø§Ù†ØªÙ‡ÙŠØª Ù…Ù† ÙƒÙ„ Ø§Ù„Ù†ØµÙˆØµ!"; }
  }

  recordBtn.onclick = startRecord;
  loadTexts();
</script>
</body>
</html>
